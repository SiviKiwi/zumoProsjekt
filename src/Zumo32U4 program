/*
* Dette er kjorefila til Zumobilen. Den benytter seg av biblioteket gruppen har laget.
* Laget av gruppe 8 BIELEKTRO V22. Alvar, Sivert og Iver.
*/

#include <arduino.h>
#include "Zumo32U4_bibliotek_gruppe_8.h"
#include <Wire.h>
#include <Zumo32U4.h>

Zumo32U4Encoders encoders;
Zumo32U4Motors motors;
Zumo32U4ButtonA buttonA;
Zumo32U4ButtonB buttonB;
Zumo32U4LCD display;
Zumo32U4_bibliotek_gruppe_8 egendefinert;

unsigned long time;
float speed;
float prevDist = 0;
float currentCapacity = 1200.0 * 3600;

bool SOSmode = false;
bool SOSmodeOneTimeOnly = false;

unsigned long sekstiSekTimerFor = 0;
unsigned long sekstiSekTimerEtter = 0;
unsigned long sekstiSekTimer = 0;

float sekstiSekMaksHastighet = 0;
float gjennomsnittsHastighet = 0;
float sekstiSekunderDist = 0;
float prevSekstiSekunderDist = 0;

unsigned long tid70 = 0;
unsigned long tid70Etter = 0;
unsigned long tid70Differensial = 0;
const int maksHastiget = 0; // NB: husk å endre denne verdien til faktisk makshastighet.

void setup()
{
  display.init();
  time = millis();

  noInterrupts();
  TCCR1A = 0;
  TCCR1B = 0;
  TCCR1B |= 0b00000101;
  TIMSK1 |= 0b00000001;
  interrupts();
}


void loop()
{

  egendefinert.oneSecBatState(); // Denne funksjonen sjekker om det har gått ti sekunder siden
                                 // den sist. gå til library c++ for å legge til statusfunksjoner.

  int16_t countLeft = encoders.getCountsLeft();             
  int16_t countRight = encoders.getCountsRight();

  int16_t avgCount = (countLeft + countRight) / 2;

  float dist = egendefinert.getDistance(avgCount);

  unsigned long timeNow = millis(); 

  if (timeNow - time > 100)
  {
    unsigned long elapsedTime = timeNow - time;
    speed = egendefinert.getSpeed(dist - prevDist, elapsedTime);

    if((buttonB == true) && (SOSmodeOneTimeOnly == false))
    {
        SOSmode = true;
        SOSmodeOneTimeOnly = true;
    }

    egendefinert.setCapacity(speed, elapsedTime, SOSmode, currentCapacity);

    display.clear();
    display.gotoXY(0, 0);
    display.print((float)currentCapacity / 3600.0);
    display.print(dist);
    display.print(speed);

    time = millis();
    prevDist = dist;

  }
    
    
    /* Under er for sekstisekunders */


    if (sekstiSekTimerFor == 0)
    {
        sekstiSekTimerEtter = 0;
    }

    else 
    {
        sekstiSekTimerEtter = millis();   
    }

    if (speed > 0.1)
    {
        sekstiSekTimer = sekstiSekTimer + (sekstiSekTimerEtter - sekstiSekTimerFor);
        sekstiSekTimerFor = millis();
    }

    else if (speed < 0.1)
    {
        sekstiSekTimer = sekstiSekTimer + (sekstiSekTimerEtter - sekstiSekTimerFor);
        sekstiSekTimerFor = 0;
    }



    if (sekstiSekTimer > 60000)
    {
        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


        if (speed > sekstiSekMaksHastighet)
        {                 // Her henter jeg inn makshastigheten som skal vises etter seksti sekunder.
            sekstiSekMaksHastighet = speed; // VIKTIG
        }


        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        

        GjennomsnittsHastighet = (sekstiSekunderDist - prevSekstiSekunderDist)/60; // VIKTIG
        prevSekstiSekunderDist = sekstiSekunderDist;


        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


        if (speed > maksHastiget)
        {
            tid70 = millis();
        }

        if (speed < maksHastiget)
        {
            tid70Etter = millis();
            tid70Differensial = tid70Etter - tid70; // VIKTIG
        }


        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

    sekstiSekTimer = 0;

    }
}


/* Det går ann å kutte ned på koden jeg har skrevet, men for å få det inn i
   funksjoner så må man få funksjonene til å levere lister/tupler/arrays og 
   deretter ha variabler som kan fange opp de ulike delene av lister/tupler/array. */





   /* Under her er koden til displayets */


ISR(TIMER1_OVF_VECT)
{  
    TCNT1 = 31250;
    egendefinert.vectorOverflow(); 
}



/* Under her kommer funksjoner som jeg skal forkorte hovedprogrammet med*/
        // Jeg er skeptisk til om disse kommer til å fungere.


float distance()  // Denne funksjonen erstatter distanse koden. 
{
  int16_t countLeft = encoders.getCountsLeft();
  int16_t countRight = encoders.getCountsRight();

  int16_t avgCount = (countLeft + countRight) / 2;

  float dist = Zumo32U4_bibliotek_gruppe_8::getDistance(avgCount);

  return dist;
}







unsigned long sekstiSekTimerFor = 0;
unsigned long sekstiSekTimerEtter = 0;
unsigned long sekstiSekTimer = 0;

unsigned long findSekstiSekTid()
{

    if (sekstiSekTimerFor == 0)
    {
        sekstiSekTimerEtter = 0;
    }

    else 
    {
        sekstiSekTimerEtter = millis();   
    }

    if (speed > 0.1)
    {
        sekstiSekTimer = sekstiSekTimer + (sekstiSekTimerEtter - sekstiSekTimerFor);
        sekstiSekTimerFor = millis();
    }

    else if (speed < 0.1)
    {
        sekstiSekTimer = sekstiSekTimer + (sekstiSekTimerEtter - sekstiSekTimerFor);
        sekstiSekTimerFor = 0;
    }

    return sekstiSekTimer;
}









float sekstiSekMaksHastighet = 0;
float gjennomsnittsHastighet = 0;
float sekstiSekunderDist = 0;
float prevSekstiSekunderDist = 0;

unsigned long tid70 = 0;
unsigned long tid70Etter = 0;
unsigned long tid70Differensial = 0;
const int maksHastiget = 0; // NB: husk å endre denne verdien til faktisk makshastighet.


unsigned long speedometerEvery60(float speed, const int maksHastiget)
{

if (Zumo32U4_bibliotek_gruppe_8::findSekstiSekTid > 60000)
    {
        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


        if (speed > sekstiSekMaksHastighet)
        {                 // Her henter jeg inn makshastigheten som skal vises etter seksti sekunder.
            sekstiSekMaksHastighet = speed; // VIKTIG
        }


        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        

        GjennomsnittsHastighet = (sekstiSekunderDist - prevSekstiSekunderDist)/60; // VIKTIG
        prevSekstiSekunderDist = sekstiSekunderDist; // sekstiSekunderDist trenger en verdi.


        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


        if (speed > maksHastiget)
        {
            tid70 = millis();
        }

        if (speed < maksHastiget)
        {
            tid70Etter = millis();
            tid70Differensial = tid70Etter - tid70; // VIKTIG
        }


        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

    sekstiSekTimer = 0;

    }

    unsigned long resultArray[0] = sekstiSekMaksHastighet;
    resultArray[1] = GjennomsnittsHastighet;
    resultArray[2] = tid70Differensial;

    return resultArray;
}




// Dette er en test for pull